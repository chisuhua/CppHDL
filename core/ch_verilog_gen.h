// core/ch_verilog_gen.h
#pragma once

#include "min_cash.h"
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>

namespace ch {
namespace core {

class VerilogGenerator {
private:
    std::string module_name_;
    std::ofstream verilog_file_;

    // 简单的中间表示
    struct SignalDecl {
        std::string name;
        int width;
        bool is_input;
        bool is_output;
        bool is_register;
    };

    std::vector<SignalDecl> declarations_;
    std::vector<std::string> always_blocks_; // 存储 always 块的代码
    std::vector<std::string> assign_statements_; // 存储 assign 语句

    // 辅助函数：为信号生成唯一的 Verilog 名称
    std::string get_verilog_name(const std::string& base_name, bool is_reg = false) {
        static int counter = 0;
        if (is_reg) {
            return base_name + "_reg_" + std::to_string(counter++);
        } else {
            return base_name + "_" + std::to_string(counter++);
        }
    }

    // 辅助函数：将 ch_uint<N> 宽度转换为字符串
    template<int N>
    std::string width_to_string() {
        if (N == 1) {
            return "";
        } else {
            return "[" + std::to_string(N-1) + ":0]";
        }
    }

public:
    VerilogGenerator(const std::string& module_name, const std::string& filename)
        : module_name_(module_name) {
        verilog_file_.open(filename, std::ios::out | std::ios::trunc);
        if (!verilog_file_.is_open()) {
            std::cerr << "  [VerilogGen] Failed to open file: " << filename << std::endl;
        }
    }

    ~VerilogGenerator() {
        if (verilog_file_.is_open()) {
            verilog_file_.close();
        }
    }

    // 声明一个输入端口
    template<int N>
    void declare_input(const std::string& name) {
        declarations_.push_back({name, N, true, false, false});
    }

    // 声明一个输出端口
    template<int N>
    void declare_output(const std::string& name) {
        declarations_.push_back({name, N, false, true, false});
    }

    // 声明一个寄存器
    template<int N>
    void declare_register(const std::string& name) {
        declarations_.push_back({name, N, false, false, true});
    }

    // 添加一个组合逻辑赋值语句 (assign)
    void add_assign(const std::string& lhs, const std::string& rhs) {
        assign_statements_.push_back("assign " + lhs + " = " + rhs + ";");
    }

    // 添加一个时序逻辑块 (always @(posedge clk))
    void add_always_block(const std::string& block_content) {
        always_blocks_.push_back(block_content);
    }

    // 生成完整的 Verilog 文件
    void generate() {
        if (!verilog_file_.is_open()) return;

        verilog_file_ << "// Auto-generated by Mini-CaSH Verilog Generator\n";
        verilog_file_ << "module " << module_name_ << " (\n";

        // 声明端口
        std::vector<std::string> port_list;
        for (const auto& decl : declarations_) {
            if (decl.is_input || decl.is_output) {
                port_list.push_back("    " + decl.name);
            }
        }
        for (size_t i = 0; i < port_list.size(); ++i) {
            verilog_file_ << port_list[i];
            if (i < port_list.size() - 1) verilog_file_ << ",";
            verilog_file_ << "\n";
        }
        verilog_file_ << ");\n\n";

        // 声明信号
        for (const auto& decl : declarations_) {
            std::string type = "wire";
            if (decl.is_register) type = "reg";
            std::string width = (decl.width == 1) ? "" : "[" + std::to_string(decl.width-1) + ":0]";
            verilog_file_ << "    " << type << " " << width << " " << decl.name << ";\n";
        }
        verilog_file_ << "\n";

        // 生成 assign 语句
        for (const auto& stmt : assign_statements_) {
            verilog_file_ << "    " << stmt << "\n";
        }
        if (!assign_statements_.empty()) verilog_file_ << "\n";

        // 生成 always 块
        for (const auto& block : always_blocks_) {
            verilog_file_ << "    always @(posedge clk) begin\n";
            verilog_file_ << "        " << block << "\n";
            verilog_file_ << "    end\n\n";
        }

        verilog_file_ << "endmodule\n";
    }
};

// 全局函数：生成 Verilog
template<typename T>
void ch_toVerilog(const std::string& filename, ch_device<T>& device) {
    // 这里需要调用 device.describe() 来“收集”硬件信息
    // 但当前架构不支持，所以我们为 CounterModule 写一个特化版本
    // 作为 MVP，我们直接为 CounterModule 生成代码

    VerilogGenerator gen("CounterModule", filename);

    // 假设我们知道 CounterModule 的结构
    gen.declare_input<1>("clk");
    gen.declare_input<1>("rst");
    gen.declare_output<4>("count");
    gen.declare_register<4>("reg");

    // 组合逻辑: count = reg + 1
    gen.add_assign("count", "reg + 4'd1");

    // 时序逻辑: reg <= (rst) ? 4'd0 : reg + 4'd1
    gen.add_always_block("if (rst) begin\n        reg <= 4'd0;\n    end else begin\n        reg <= reg + 4'd1;\n    end");

    gen.generate();

    std::cout << "  [ch_toVerilog] Verilog file generated: " << filename << std::endl;
}

} // namespace core
} // namespace ch
